<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.ipfs.spec</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>IPFS client schemas.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.ipfs.spec
  (:require
   [com.kubelt.spec.http :as spec.http]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO migrate these into shared com.kubelt.spec namespace when they aren't specific to this IPFS client implementation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Schema</h2>Describe the shape of the map used to describe an IPFS RESTful APIresource endpoint.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def api-base
  [:map
   [:api/version :keyword]
   [:path/prefix :string]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO is there a more general way, ideally provided by malli itself, to validate that a given data value is a valid schema itself? Using :schema naiively doesn't appear to work.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def api-spec
  :any
  #_:schema
  #_[:or :keyword :map :symbol :vector])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>A vector of supported HTTP methods.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def http-methods
  [:vector spec.http/method])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def media-types
  [:vector spec.http/media-type])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def api-params
  [:map-of {:closed true}
   :keyword
   [:map
    [:name spec.http/param-name]
    [:description :string]
    [:required :boolean]
    [:spec api-spec]]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def param-conflicts
  [:vector
   [:set :keyword]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Spec for the IPFS method map descriptor.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def api-resource
  [:map {:closed true}
   [:com.kubelt/type [:enum :kubelt.type/api-resource]]
   [:resource/description :string]
   [:resource/methods http-methods]
   [:resource/path :string]
   ;; TODO map must have only single entry as there can only be a single
   ;; request body? True for multipart/form-data?
   [:resource/body {:optional true} api-params]
   ;; A body fn transforms the supplied value for the body into
   ;; something our HTTP client knows how to deal with, e.g. a set of
   ;; maps representing multipart form data.
   [:resource/body-fn {:optional true}
    [:=&gt; [:cat spec.http/param-name :any]
     [:or spec.http/multipart]]]
   [:resource/conflicts {:optional true} param-conflicts]
   [:resource/params api-params]
   [:response/types media-types]
   [:response/spec api-spec]
   [:response/body-fn {:optional true}
    ;; TODO replace :map argument with recursive reference to
    ;; api-resource (using registry?).
    [:=&gt; [:cat :map :any] :any]]
   ;; Added by parameter checking functions.
   ;; TODO Should we create a separate spec for this enriched data?
   ;; TODO flesh out these specs.
   [:http/request {:optional true} :map]
   [:parameter/spec {:optional true} [:vector :any]]
   ;; The generated map of options for the API call is stored on the
   ;; resource map. The map has to conform to the generated parameter
   ;; spec.
   [:parameter/data {:optional true} :map]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Options for (client/init).</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def init-options
  [:map {:closed true}
   [:client/keywordize?
    {:optional true
     :description &quot;Convert response keys to keywords?&quot;}
    :boolean]
   [:client/validate?
    {:optional true
     :description &quot;Validate the parsed response body?&quot;}
    :boolean]
   [:client/timeout
    {:optional true
     :description &quot;Request timeout in milliseconds.&quot;}
    :int]
   [:client/node-info?
    {:optional true
     :description &quot;Pre-fetch and store node information.&quot;}
    :boolean]
   [:http/client
    {:optional true
     :description &quot;An existing HTTP client to use.&quot;}
    ;; TODO tighten this up; satisfies? HttpClient
    :any]
   [:http/scheme
    {:optional true
     :description &quot;The protocol scheme to use to talk to IPFS&quot;
     :example :http}
    spec.http/scheme]
   [:http/host
    {:optional true
     :description &quot;An IP address for the IPFS server&quot;}
    spec.http/host]
   [:http/port
    {:optional true
     :description &quot;A TCP port for the IPFS server&quot;}
    spec.http/port]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Params</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def peer-id
  [:and
   {:example &quot;12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def public-key
  [:and
   {:example &quot;CAESIGdvXZHqB6Sbr9gEF9Z1XaWEYNOjC6iW1PFl+jpHE/E4&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def addresses
  [:and
   {:example
    [&quot;/ip4/127.0.0.1/tcp/4001/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;
     &quot;/ip4/127.0.0.1/udp/4001/quic/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;
     &quot;/ip4/192.168.68.105/tcp/4001/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;
     &quot;/ip4/192.168.68.105/udp/4001/quic/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;
     &quot;/ip4/206.248.184.135/tcp/63760/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;
     &quot;/ip4/206.248.184.135/udp/63760/quic/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;
     &quot;/ip6/::1/tcp/4001/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;
     &quot;/ip6/::1/udp/4001/quic/p2p/12D3KooWGn8esyGN8DB1UCsVTZPWxkr6ELGBP9AffLNQqbrfejv7&quot;]}
   :vector])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def agent-version
  [:and
   {:example &quot;go-ipfs/0.11.0/&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def protocol-version
  [:and
   {:example &quot;ipfs/0.1.0&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def protocols
  [:and
   {:example
    [&quot;/ipfs/bitswap&quot;
     &quot;/ipfs/bitswap/1.0.0&quot;
     &quot;/ipfs/bitswap/1.1.0&quot;
     &quot;/ipfs/bitswap/1.2.0&quot;
     &quot;/ipfs/id/1.0.0&quot;
     &quot;/ipfs/id/push/1.0.0&quot;
     &quot;/ipfs/kad/1.0.0&quot;
     &quot;/ipfs/lan/kad/1.0.0&quot;
     &quot;/ipfs/ping/1.0.0&quot;
     &quot;/libp2p/autonat/1.0.0&quot;
     &quot;/libp2p/circuit/relay/0.1.0&quot;
     &quot;/libp2p/circuit/relay/0.2.0/hop&quot;
     &quot;/libp2p/circuit/relay/0.2.0/stop&quot;
     &quot;/p2p/id/delta/1.0.0&quot;
     &quot;/x/&quot;]}
   :vector])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def key-name
  [:and
   {:example &quot;self&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def key-id
  [:and
   {:example &quot;k51qzi5uqu5direb9al94reti397oxnp93oeucvf6hkte8nebtj5otqr7d8k6w&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def key-type
  [:and
   {:example &quot;ed25519&quot;}
   [:enum &quot;rsa&quot; &quot;ed25519&quot;]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def key-size
  [:and
   {:example 128}
   :int])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def ipns-base
  [:and
   {:example &quot;b58mh&quot;}
   [:enum &quot;b58mh&quot; &quot;base36&quot; &quot;base32&quot; &quot;k&quot;]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def peerid-base
  [:and
   {:example &quot;base36&quot;}
   [:enum &quot;b58mh&quot; &quot;base36&quot; &quot;base32&quot; &quot;k&quot;]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def ipns-name
  [:and
   {:example &quot;k51qzi5uqu5direb9al94reti397oxnp93oeucvf6hkte8nebtj5otqr7d8k6w&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def ipfs-path
  [:and
   {:example &quot;/ipfs/bafyreid7jv35hibnc3fq2nzacom57gihwfh5e4yp5onoyf2vosybfjf4ua&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def dag-codec
  [:and
   {:example &quot;dag-cbor&quot;}
   [:enum &quot;dag-cbor&quot; &quot;dag-json&quot;]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO flesh this out to conform to DAG-JSON spec, include CIDs</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def dag-json
  [:or
   {:description &quot;DAG-JSON data&quot;
    :example {:foo [&quot;bar&quot; :baz]}}
   vector?
   map?])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO is there more we can say here?</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def dag-cbor
  [:or
   {:description &quot;CBOR-encoded binary data.&quot;}
   spec.http/uint8-array])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def dag-hash
  [:and
   {:example &quot;sha2-256&quot;}
   [:enum
    ;; This hash is nominally supported but waiting on a bug fix:
    ;; &gt; https://github.com/ipfs/go-ipfs/issues/8650
    ;; TODO enable this option when possible; it's fast!
    ;;&quot;blake3&quot;
    &quot;keccak-256&quot;
    &quot;keccak-512&quot;
    &quot;md5&quot;
    &quot;sha1&quot;
    &quot;sha2-256&quot;
    &quot;sha2-512&quot;
    &quot;sha3-224&quot;
    &quot;sha3-256&quot;
    &quot;sha3-384&quot;
    &quot;sha3-512&quot;
    &quot;shake-128&quot;
    &quot;shake-256&quot;]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def content-id
  [:and
   {:description &quot;A multiformat content identifier.&quot;
    :example &quot;bagiacgzah24drzou2jlkixpblbgbg6nxfrasoklzttzoht5hixhxz3rlncyq&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def dht
  [:and
   {:description &quot;An IPFS DHT table name.&quot;
    :example &quot;lan&quot;}
   [:enum &quot;wanserver&quot; &quot;lanserver&quot; &quot;wan&quot; &quot;lan&quot;]])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def api-endpoint
  [:and
   {:description &quot;A remote pinning service endpoint.&quot;
    :example &quot;https://api.pinata.cloud/psa&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def codec-code
  [:and
   {:description &quot;A CID multibase code identifier&quot;
    :example 70}
   :int])</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def codec-name
  [:and
   {:description &quot;A CID multibase code name&quot;
    :example &quot;base58btc&quot;}
   :string])</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
