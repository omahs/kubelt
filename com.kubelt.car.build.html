<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.car.build</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Build Content Archives.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.car.build
  {:copyright &quot;Â©2022 Kubelt, Inc.&quot; :license &quot;UNLICENSED&quot;}
  (:require
   [&quot;@ipld/dag-cbor&quot; :as codec-cbor]
   [&quot;@ipld/dag-json&quot; :as codec-json]
   [&quot;multiformats/codecs/raw&quot; :as codec-raw :refer [TextEncoder]]
   [&quot;multiformats/hashes/sha2&quot; :as hashes.sha2])
  (:require
   [com.kubelt.car.block :as car.block]
   [com.kubelt.lib.bag.check :as bag.check]
   [com.kubelt.lib.ipld :as ipld]
   [com.kubelt.lib.promise :as promise]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Maps from a keyword to an IPLD codec implementation that can be used to encode a block.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- kw-&gt;codec
  [kw]
  {:pre [(some #{kw} ipld/supported-codecs)]}
  (condp = kw
    :ipld.codec/raw codec-raw
    :ipld.codec/cbor codec-cbor
    :ipld.codec/json codec-json))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Maps from a keyword to a hash implementation that will be used to summarize the contents of a block.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- kw-&gt;hasher
  [kw]
  {:pre [(some #{kw} ipld/supported-hashers)]}
  (condp = kw
    ;; TODO support more hashes
    ;;:ipld.hash/blake3-256 hashes/blake3
    :ipld.hasher/sha2-256 hashes.sha2/sha256))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert a DAG node into a block. The :ipld/codec and :ipld/hasher fields of the node determine the block encoding.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- node-&gt;block
  [{:keys [ipld/codec ipld/hasher kubelt.node/data] :as node}]
  {:pre [(bag.check/node? node)]}
  (let [encoder (kw-&gt;codec codec)
        hasher (kw-&gt;hasher hasher)
        ;; The encoder is a function that can turn Clojure data into
        ;; IPLD blocks. This function accepts a data value and returns a
        ;; promise that resolves to the encoded block.
        encoder-fn (car.block/encoder encoder hasher)
        ;; TODO FIXME if no children (a leaf node), nothing to do. If
        ;; there are children then must be replaced by their CIDs and
        ;; folded into the node data.
        ;;data (if (seq? children) {:data data :children [:fixme]} data)
        ]
    (encoder-fn data)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert a DAG into a block map. Returns a promise that resolves when all of the nodes in the DAG have been converted. The resolved is a map has a :root key whose value is the CID of the root block, and a sequence of blocks stored as the value of the :blocks key.</p><p>TODO write spec for car map TODO test me</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- dag-&gt;blocks
  [dag]
  {:pre [(bag.check/dag? dag)]}
  (let [;; TEMP
        blocks-ps [(node-&gt;block (:kubelt.dag/root dag))]]
    (-&gt; (promise/all blocks-ps)
        (promise/then
         (fn [blocks]
           (let [root-block (first blocks)
                 root-cid (car.block/block-&gt;cid root-block)]
             {:root root-cid :blocks blocks}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn car?
  [x]
  (and
   (map? x)
   (= :kubelt.car/car (:kubelt/type x))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert a BAG into a map that contains the sequence of blocks to be stored in the CAR, and a sequence of block roots. Note that not every block is a root. This mirrors the structure of the CAR and makes it a straightforward procedure to generate a CAR on disk.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn car
  [bag]
  {:pre [(bag.check/bag? bag)] :post [(promise/promise? %)]}
  (let [dag-set (get bag :kubelt.bag/dag)
        ;; Returns a collection of promises.
        blocks-ps (map dag-&gt;blocks dag-set)]
    (-&gt; (promise/all blocks-ps)
        (promise/then
         (fn [block-maps]
           (let [blocks (mapcat :blocks block-maps)
                 roots (map :root block-maps)]
             {:kubelt/type :kubelt.car/car
              :kubelt.car/blocks blocks
              :kubelt.car/roots roots}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
